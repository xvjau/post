---
date: "2015-04-27"
title: C, C++, Engenharia Reversa e Todo o Resto
tags: [ "blogue" ]
---
![](/images/p3q06SA.png)

"C++ é divertido, mas não paga minhas contas". Por diversas coincidências da natureza, e um bocado de empenho deste que vos fala, essa frase não precisa ser dita por mim. Tendo programado em casa por 2 ou 3 anos e lido [The C Programming Language](http://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628/ref=asap_bc?ie=UTF8) um bocado de vezes antes de me aventurar no mercado de trabalho, tive a oportunidade de começar na área já programando em C, C++, e com uma equipe peso-pesado. Programávamos para Windows, onde as coisas não são tão fáceis quanto no Linux (que é um SO de e para programadores), e onde precisa-se comer muita farinha com sintaxe para construir coisas decentes. Portabilidade às vezes é um objetivo, às vezes é deixado de lado. A API Win32 já é bruta demais, e o cliente sempre tem um prazo apertado demais.

Hoje, uns 15 anos depois, minha carreira foi 95% asfaltada com C e C++, com pitadas de Assembly e recentemente Python. De vez em quanto, .NET, Java e até VB, porque a gente merece um descanso de vez em quando. Essa semana um leitor me perguntou como começar a trilhar esse caminho tão divertido do médio-nível. Não só isso: com pitadas de engenharia reversa. Como eu não sou um professor, infelizmente não vou conseguir dar uma resposta à altura, mas posso compartilhar um pouco meus pensamentos sobre meu passado.

![](/images/IAQvt92.jpg)

Na engenharia reversa, por exemplo, segui um caminho parecido com C: brincava de crackear os programas em casa. "Como destavar o WinRar?", "Como não deixar expirar aquele programinha que veio no CD?". Respostas à essas perguntas geralmente demoravam dias, semanas ou até meses. Mas não importava. Desde que fosse divertido -- e era, muito! -- sempre haveria vontade de caminhar cada vez mais para encontrar a resposta. Esse "caminho" que eu uso como metáfora geralmente não é muito bem pavimentado, não tem atalhos, mas tem diversas vielas que irão dar em paisagens fantásticas que irão te fazer perder um tempo imenso, mas deliciosamente divertido. Me lembro até hoje que minha maior diversão quando conheci os computadores foi tentar chegar o máximo possível do hardware para entender como diabos um impulso elétrico consegue fazer tanta coisa diferente. Não preciso dizer que isso deve ter me custado um ano e vários livros, cada um em uma camada mais embaixo de abstração.

A questão sobre o aprendizado é: para aprender como um autodidata nada mais fácil do que tentar responder perguntas cuja resposta você esteja morrendo de curiosidade para saber. Só assim para esbarrar, por exemplo, no Assembly, e dedicar alguns meses lendo uns livros sobre o assunto, fazendo testes, abrindo um depurador que nunca viu na vida e aprendendo cometendo mais erros que acertos. Só com uma curiosidade infinita para ir além sem precisar de incentivos, sem temer a tão temida hoje em dia procrastinação. O Facebook/Twiter nunca serão tão divertidos quanto o poder de criação de um programador em suas mãos, ou o poder de desmontar um software engenhoso. Não se você já gostar dessa área. E se você gosta, provavelmente já sabe disso. Ou quer saber.

Durante minha estadia na [Open](http://www.opencs.com.br) fiz uma pequena palestra explicando as coisas que eu precisava conhecer a fundo, mas que podem ser facilmente apreendidas por iniciantes (como eu fui), passo-a-passo, na análise de trojans de Windows. Acho que o conteúdo se aplica para quem quer começar a fuçar e não sabe por onde começar. No fundo o conteúdo era mais ou menos o que eu gostaria que me fosse ensinado antes que eu tivesse que gastar mais alguns meses com livros inteiros. Mas não me arrependo desses livros inteiros. Muitos foram úteis, outros inúteis, mas são as cicatrizes que tornam o aprendizado mais forte. Cicatrizes? Os erros de percurso!

http://pt.slideshare.net/slideshow/embed_code/key/cgeTnnM8pSIG0O

Se me perguntassem a respeito da facilidade de aprender essa ou aquela linguagem, aprender essa ou aquela técnica, qual o melhor para começar eu diria que depende. E muito. Cada profissional tem o seu histórico de vida e de trabalho. E cada um tem o seu ritmo. Eu sou uma pessoa devagar. Eu preciso repetir as mesmas coisas várias vezes para conseguir fixar um novo aprendizado. Porém, quando fixo, dificilmente esqueço. Foi assim com a linguagem C, cujo padrão fiquei quase decorando (um dos anexos do livro que citei no início tem a gramática completa, é uma linguagem simples). No entanto, demorei tempo demais para partir para o C++. Porém, quando comecei a ler [The C++ Programming Language](http://www.stroustrup.com/4th.html) já tinha um _background_ do que era C++, como ele nasceu e como ele evoluiu para um padrão internacional. Já existia internet, e tudo ficou mais fácil com internet (especialmente para autodidatas). Hoje em dia apenas os analfabetos e os preguiçosos não conseguem aprender alguma coisa se tiverem internet. E olhe que quem está escrevendo isso é um preguiçoso nato. Tem semanas que sou um procrastinador profissional. Porém, quando algo aguça minha curiosidade, eu viro um computador processando um programa que só irá terminar depois de uma resposta satisfatória.

![](/images/CjWnz7v.jpg)

Foi assim com C++, talvez uma camada de abstração acima de C, mas igualmente divertido, pois trazia o poder de processamento e acesso a hardware já presente em C. Os novos paradigmas que a STL apresentava pareciam alienígenas, e acho que não me habituaria hoje em dia com contêineres se não tivesse lido com muita atenção o livro-mestre de Bjarne Stroustrup. Nem templates. Templates são um quebra-cabeças para quem está pensando em tipos, pois eles não são tipos. É o mesmo quebra-cabeças que algumas novidades como namespaces fazem com a nossa cabeça. Estava acostumado a tipos, comandos e expressões. Essas novidades do C++ foram um passo além, e que valeu a pena.

Uma possível evolução disso seriam as linguagens funcionais. Dizem que é o futuro. Por enquanto, não paga a conta de muita gente. Assim como as famigeradas C e C++. No entanto, se isso for sempre o seu balizador de conhecimento, estará sempre à mercê do mercado, que não sabe de nada sobre os seus gostos, seus interesses, suas ambições. Conhecimento é uma ambição muito "mais infinita" e muito mais recompensadora que dinheiro. O conhecimento tem o poder de fazer mais dinheiro, e não o contrário. Portanto, tenha a curiosidade, e atenda aos seus chamados. O resto o destino se vira.
